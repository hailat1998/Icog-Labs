! (import! &kb kb)

(= minsup 2)

! (add-reduct &self (= (pattern-space) (new-space)))



(= (pattern $x $y)
   (match &kb (Inheritance $x $y)
         (Inheritance $x $y)))

! (pattern $x $y)


(= (count $x $val)
   (
    if(== $x ()) $val
    (count (cdr-atom $x) (+ $val 1))))

! (count (collapse (pattern $x $y)) 0)

(= (checkSup $count )
        (if(>= $count minsup)
            (Supported)
            (Error Below Support)))

! (checkSup (count (collapse (pattern $x $y)) 0))

(= (matchX)(
    collapse (match &self (Inheritance $x $y)
         $x )
))

(= (matchY)(
 collapse (match &self (Inheritance $x $y)
         $y )
))


! (matchX)
! (matchY)

(= (valuation $x $y)
   (let* (($patternX (matchX))
          ($patternY (matchY))
        ( $valX (cons-atom x-> $patternX))
        ( $valY (cons-atom y-> $patternY)))
        (cons-atom $valX ($valY))))

! (valuation $x $y)


; Used "|" as delimiter to separate the variable x from from variable y.
 (= (shab)
   (let* (
          ($shabX ( matchX))
          ($shabY ( matchY))
        ( $mshabX (cons-atom $shabX (Variable y)))
        ( $mshabX| (cons-atom $mshabX (|))))
        (cons-atom $mshabX| $shabY)))

!(shab)



(= (specializeX $x)
   (add-atom (pattern-space)
             (= (pattern $y)
                (Inheritance $x $y))))




(= (specializeY $y)
   (add-atom (pattern-space)
             (= (pattern $x)
                (Inheritance $x $y))))




(= (specialize $shab $endX)
   (let $val (car-atom $shab)
        (cond
          ((and (!= $val '|) (not $endX))
           (specializeY $val)
           (specialize (cdr-atom $shab) False))
          ((== $val '|)
           (specialize (cdr-atom $shab) True))
          (else
           (specializeX $val)
           (specialize (cdr-atom $shab) True)))))


! (specialize shab False)




